// xlocale internal header (from <locale>)
#pragma once
#ifndef _XLOCALE_
#define _XLOCALE_
#ifndef RC_INVOKED
#include <climits>
#include <cstring>
#include <stdexcept>
#include <typeinfo>
#include <xdebug>
#include <xlocinfo>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#pragma warning(push,3)
#pragma warning(disable:4412)
#endif  /* _MSC_VER */

_STD_BEGIN

		// TEMPLATE CLASS _Locbase
template<class _Dummy>
	class _Locbase
	{	// define templatized category constants, instantiate on demand
public:
	_PGLOBAL static const int collate = _M_COLLATE;
	_PGLOBAL static const int ctype = _M_CTYPE;
	_PGLOBAL static const int monetary = _M_MONETARY;
	_PGLOBAL static const int numeric = _M_NUMERIC;
	_PGLOBAL static const int time = _M_TIME;
	_PGLOBAL static const int messages = _M_MESSAGES;
	_PGLOBAL static const int all = _M_ALL;
	_PGLOBAL static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		// CLASS locale
class locale;
template<class _Facet>
	const _Facet& __CRTDECL use_facet(const locale&);

// warning 4412 is benign here
#pragma warning(push)
#pragma warning(disable:4412)
class _CRTIMP2_PURE locale
	: public _Locbase<int>
	{	// nonmutable collection of facets that describe a locale
public:
	typedef int category;

			// CLASS id
	class _CRTIMP2_PURE id
		{	// identifier stamp, unique for each distinct kind of facet
	public:
		__CLR_OR_THIS_CALL id(size_t _Val = 0)
			: _Id(_Val)
			{	// construct with specified stamp value
			}

		__CLR_OR_THIS_CALL operator size_t()
			{	// get stamp, with lazy allocation
			if (_Id == 0)
				{	// still zero, allocate stamp
				_BEGIN_LOCK(_LOCK_LOCALE)
					if (_Id == 0)
						_Id = ++_Id_cnt;
				_END_LOCK()
				}
			return (_Id);
			}

	private:
		__CLR_OR_THIS_CALL id(const id&);	// not defined
		id& __CLR_OR_THIS_CALL operator=(const id&);	// not defined

		size_t _Id;	// the identifier stamp
		static _MRTIMP2_NPURE int& __cdecl _Id_cnt_func();
#ifdef _M_CEE_PURE
		static int& _Id_cnt;	// static source of unique stamps
#else
		__PURE_APPDOMAIN_GLOBAL static int _Id_cnt;	// static source of unique stamps
#endif
		};

	class _Locimp;

			// class facet
	class _CRTIMP2_PURE facet
		{	// base class for all locale facets, performs reference counting
		friend class locale;
		friend class _Locimp;

	public:
		static size_t __CLRCALL_OR_CDECL _Getcat(const facet ** = 0)
			{	// get category value, or -1 if no corresponding C category
			return ((size_t)(-1));
			}

		void __CLR_OR_THIS_CALL _Incref()
			{	// safely increment the reference count
			_BEGIN_LOCK(_LOCK_LOCALE)
				if (_Refs < (size_t)(-1))
					++_Refs;
			_END_LOCK()
			}

		facet *__CLR_OR_THIS_CALL _Decref()
			{	// safely decrement the reference count, return this when dead
			_BEGIN_LOCK(_LOCK_LOCALE)
				if (0 < _Refs && _Refs < (size_t)(-1))
					--_Refs;
				return (_Refs == 0 ? this : 0);
			_END_LOCK()
			}

		void __CLR_OR_THIS_CALL _Register()
			{
			facet_Register(this);
			}

 #if defined(_DEBUG)
		void * __CLRCALL_OR_CDECL operator new(size_t _Size)
			{	// replace operator new
			return (operator new(_Size, std::_DebugHeapTag_func(),
				__FILE__, __LINE__));
			}

		void * __CLRCALL_OR_CDECL operator new(size_t _Size,
			const std::_DebugHeapTag_t& _Tag, __in_z_opt char *_File, int _Line)
			{	// replace debugging operator new
			return (::operator new(_Size, _Tag, _File, _Line));
			}

		void __CLRCALL_OR_CDECL operator delete(void *_Ptr,
			const std::_DebugHeapTag_t&, __in_z_opt char *, int)
			{	// replace debugging operator delete
			operator delete(_Ptr);
			}

		void __CLRCALL_OR_CDECL operator delete(void *_Ptr)
			{	// replace operator delete
			std::_DebugHeapDelete((facet*)_Ptr);
			}
 #endif /* defined(_DEBUG) */


//	_PROTECTED:
		virtual __CLR_OR_THIS_CALL ~facet()
			{	// destroy the object
			}

	protected:
		explicit __CLR_OR_THIS_CALL facet(size_t _Initrefs = 0)
			: _Refs(_Initrefs)
			{	// construct with initial reference count
			}

	private:
		_MRTIMP2_NPURE static void __cdecl facet_Register(facet *);	// queue up lazy facet for destruction

		__CLR_OR_THIS_CALL facet(const facet&);	// not defined
		facet& __CLR_OR_THIS_CALL operator=(const facet&);	// not defined

		size_t _Refs;	// the reference count
		};

			// CLASS _Locimp
	class _CRTIMP2_PURE _Locimp
		: public facet
		{	// reference-counted actual implementation of a locale
	_PROTECTED:
		__CLR_OR_THIS_CALL ~_Locimp()
			{
			_Locimp_dtor(this);
			}

	private:
		static _MRTIMP2_NPURE void __cdecl _Locimp_dtor(_Locimp *); // destoy the object
		static _MRTIMP2_NPURE void __cdecl _Locimp_ctor(_Locimp *,const _Locimp&);	// copy a _Locimp
		static _MRTIMP2_NPURE void __cdecl _Locimp_Addfac(_Locimp *,facet *, size_t);	// add a facet
		friend class locale;

		__CLR_OR_THIS_CALL _Locimp(bool _Transparent = false)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent), _Name("*")
			{ }
		
		__CLR_OR_THIS_CALL _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name(_Right._Name)
			{
			_Locimp_ctor(this, _Right);
			}
		
		void __CLR_OR_THIS_CALL _Addfac(facet *_Pfacet, size_t _Id)
			{
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _MRTIMP2_NPURE _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make essential facets

		static _MRTIMP2_NPURE void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make wchar_t facets

 #ifdef _NATIVE_WCHAR_T_DEFINED
		static _MRTIMP2_NPURE void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make ushort facets
 #endif /* _NATIVE_WCHAR_T_DEFINED */

		static _MRTIMP2_NPURE void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	// make remaining facets

		facet **_Facetvec;	// pointer to vector of facets
		size_t _Facetcount;	// size of vector of facets
		category _Catmask;	// mask describing implemented categories
		bool _Xparent;	// true if locale is transparent
		_STRING_CRT _Name;	// locale name, or "*" if not known

		static _MRTIMP2_NPURE _Locimp *& __cdecl _Clocptr_func();	// pointer to "C" locale object
#ifdef _M_CEE_PURE
		static _Locimp *&_Clocptr;	// pointer to "C" locale object
#else
		__PURE_APPDOMAIN_GLOBAL static _Locimp *_Clocptr;	// pointer to "C" locale object
#endif
private:
		_Locimp& __CLR_OR_THIS_CALL operator=(const _Locimp&);	// not defined
	
		};

	_DEPRECATED locale& __CLR_OR_THIS_CALL _Addfac(facet *_Fac, size_t _Id,
		size_t _Catmask)
		{
		if (1 < this->_Ptr->_Refs)
			{	// shared, make private copy before altering
			this->_Ptr->_Decref();
			this->_Ptr = _NEW_CRT _Locimp(*this->_Ptr);
			}
		this->_Ptr->_Addfac(_Fac, _Id);

		if (_Catmask != 0)
			this->_Ptr->_Name = "*";
		return (*this);
		}

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool __CLR_OR_THIS_CALL operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	// compare _Left and _Right strings using collate facet in locale
		const std::collate<_Elem>& _Coll_fac =
			std::use_facet<std::collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale __CLR_OR_THIS_CALL combine(const locale& _Loc) const
		{	// combine two locales
		_Facet *_Facptr;

		_TRY_BEGIN
			_Facptr = (_Facet *)&std::use_facet<_Facet>(_Loc);
		_CATCH_ALL
			_THROW(runtime_error, "locale::combine facet missing");
		_CATCH_END

		_Locimp *_Newimp = _NEW_CRT _Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = 0;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		__CLR_OR_THIS_CALL locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_NEW_CRT _Locimp(*_Loc._Ptr))
		{	// construct from _Loc, replacing facet with *_Facptr
		if (_Facptr != 0)
			{	// replace facet
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			if (_Facet::_Getcat() != (size_t)(-1))
				_Ptr->_Catmask = 0, _Ptr->_Name = "*";	// no C category
			}
		}


	__CLR_OR_THIS_CALL locale() _THROW0()
		: _Ptr(_Init())
		{	// construct from current locale
		_Getgloballocale()->_Incref();
		}

	__CLR_OR_THIS_CALL locale(_Uninitialized)
		{	// defer construction
		}

	__CLR_OR_THIS_CALL locale(const locale& _Right) _THROW0()
		: _Ptr(_Right._Ptr)
		{	// construct by copying
		_Ptr->_Incref();
		}

#ifndef MRTDLL
	__CLR_OR_THIS_CALL locale(const locale& _Loc, const locale& _Other,
		category _Cat) 	// construct from locale and category in another locale
		: _Ptr(_NEW_CRT _Locimp(*_Loc._Ptr))
		{	// construct a locale by copying named facets
		_TRY_BEGIN
			_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
				_Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
					_Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
			_END_LOCINFO()
		_CATCH_ALL
			_DELETE_CRT(_Ptr->_Decref());
			_RERAISE;
		_CATCH_END
		}
#endif

#ifndef MRTDLL
	explicit __CLR_OR_THIS_CALL locale(const char *_Locname,
		category _Cat = all) 	// construct from named locale for category
		: _Ptr(_NEW_CRT _Locimp)
		{	// construct a locale with named facets
		_TRY_BEGIN
		_Init();
		_BEGIN_LOCINFO(_Lobj(_Cat, _Locname))
			if (_Lobj._Getname().compare("*") == 0)
				_THROW(runtime_error, "bad locale name");
			_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		_END_LOCINFO()
		_CATCH_ALL
		_DELETE_CRT(_Ptr->_Decref());
		_RERAISE;
		_CATCH_END
		}
#endif

#ifndef MRTDLL
	__CLR_OR_THIS_CALL locale(const locale& _Loc, const char * _Locname,
		category _Cat) 	// construct from locale and category in named locale
		: _Ptr(_NEW_CRT _Locimp(*_Loc._Ptr))
		{	// construct a locale by copying, replacing named facets
		_TRY_BEGIN
		_BEGIN_LOCINFO(_Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str()))
			bool _Hadname = _Lobj._Getname().compare("*") != 0;
			_Lobj._Addcats(_Cat, _Locname);

			if (_Hadname && _Lobj._Getname().compare("*") == 0)
				_THROW(runtime_error, "bad locale name");
			_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
		_END_LOCINFO()
		_CATCH_ALL
		_DELETE_CRT(_Ptr->_Decref());
		_RERAISE;
		_CATCH_END
		}
#endif

	__CLR_OR_THIS_CALL ~locale() _THROW0()
		{	// destroy the object
		if (_Ptr != 0)
			_DELETE_CRT(_Ptr->_Decref());
		}

	locale& __CLR_OR_THIS_CALL operator=(const locale& _Right) _THROW0()
		{	// assign a locale
		if (_Ptr != _Right._Ptr)
			{	// different implementation, point at new one
			_DELETE_CRT(_Ptr->_Decref());
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}

	string __CLR_OR_THIS_CALL name() const
		{	// return locale name
		return (_Ptr->_Name);
		}

	const facet *__CLR_OR_THIS_CALL _Getfacet(size_t _Id) const 	// get facet by id
		{	// look up a facet in locale object
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	// found facet or not transparent, return pointer
		else
			{	// look in current locale
			locale::_Locimp *_Ptr = _Getgloballocale();
			return (_Id < _Ptr->_Facetcount
				? _Ptr->_Facetvec[_Id]	// get from current locale
				: 0);	// no entry in current locale
			}
		}


	bool __CLR_OR_THIS_CALL operator==(const locale& _Loc) const
		{	// compare locales for equality
		return (_Ptr == _Loc._Ptr
			|| name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
		}

	bool __CLR_OR_THIS_CALL operator!=(const locale& _Right) const
		{	// test for locale inequality
		return (!(*this == _Right));
		}

	static _MRTIMP2_NPURE const locale& __cdecl classic();	// return classic "C" locale

	static _MRTIMP2_NPURE locale __cdecl global(const locale&);	// return current locale

	static _MRTIMP2_NPURE locale __cdecl empty();	// return empty (transparent) locale

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	// construct from _Locimp pointer
		}

	static _MRTIMP2_NPURE _Locimp *__cdecl _Getgloballocale();
	static _MRTIMP2_NPURE _Locimp *__cdecl _Init();	// initialize locale
	static _MRTIMP2_NPURE void __cdecl _Setgloballocale(void *);

	_Locimp *_Ptr;	// pointer to locale implementation object
	};
#pragma warning(pop)

		// SUPPORT TEMPLATES
template<class _Facet>
	struct _Facetptr
	{	// store pointer to lazy facet for use_facet
	__PURE_APPDOMAIN_GLOBAL static const locale::facet *_Psave;
	};

template<class _Facet>
	__PURE_APPDOMAIN_GLOBAL const locale::facet *_Facetptr<_Facet>::_Psave = 0;

template<class _Facet> inline _DEPRECATED
	locale _Addfac(locale _Loc, const _Facet *_Facptr)
		{	// add facet to locale -- retained
		return (_Loc._Addfac((_Facet *)_Facptr, _Facet::id,
			_Facet::_Getcat()));
		}

  #define _ADDFAC(loc, pfac)	locale(loc, pfac)	/* add facet to locale */

  #define _USE(loc, fac)	\
	use_facet<fac >(loc)	/* get facet reference from locale */

template<class _Facet> inline
	const _Facet& __CRTDECL use_facet(const locale& _Loc)
	{	// get facet reference from locale
	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	// got facet from locale
		else if (_Psave != 0)
			_Pf = _Psave;	// lazy facet already allocated
		else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

 #if _HAS_EXCEPTIONS
		_THROW_NCEE(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

	#else /* _HAS_EXCEPTIONS */
			abort();	// lazy disallowed
	#endif /* _HAS_EXCEPTIONS */

		else
			{	// queue up lazy facet for destruction
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();
			_Pfmod->_Register();
			}

		return ((const _Facet&)(*_Pf));	// should be dynamic_cast
	_END_LOCK()
	}

template<class _Facet> inline _DEPRECATED
	const _Facet& __CRTDECL use_facet(const locale& _Loc, const _Facet *,
		bool = false)
	{	// get facet reference from locale -- retained, 2/3 arg versions
	return use_facet<_Facet>(_Loc);
	}

		// TEMPLATE FUNCTION _Getloctxt
template<class _Elem,
	class _InIt> inline
	int __CRTDECL _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	// find field at _Ptr that matches longest in [_First, _Last)
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	// add fields with leading mark to initial count
	string _Str(_Numfields, '\0');	// one column counter for each field

	int _Ans = -2;	// no candidates so far
	for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
		{	// test each element against all viable fields
		bool  _Prefix = false;	// seen at least one valid prefix
		size_t _Off = 0;	// offset into fields
		size_t _Field = 0;	// current field number

		for (; _Field < _Numfields; ++_Field)
			{	// test element at _Column in field _Field
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	// find beginning of field

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	// skip tested columns in field
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	// matched all of field, save as possible answer
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	// save skip count if small enough
				_Ans = (int)_Field;	// save answer
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	// no match, just save skip count
			else
				_Prefix = true;	// still a valid prefix
			}

		if (!_Prefix || _First == _Last)
			break;	// no pending prefixes or no input, give up
		}
	return (_Ans);	// return field number or negative value on failure
	}

		// TEMPLATE FUNCTION _Maklocbyte
#define _MAKLOCBYTE(Elem, chr, cvt) \
	_Maklocbyte((_Elem)chr, cvt)	/* convert Elem to char */

template<class _Elem> inline
	char __CRTDECL _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	// convert _Elem to char using _Cvtvec
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __CRTDECL _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert wchar_t to char using _Cvtvec
	char _Byte = '\0';
	_Mbstinit(_Mbst1);
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 #ifdef _CRTBLD_NATIVE_WCHAR_T
template<> inline
	char __CRTDECL _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert unsigned short to char using _Cvtvec
	char _Byte = '\0';
	_Mbstinit(_Mbst1);
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #endif /* _CRTBLD_NATIVE_WCHAR_T */

		// TEMPLATE FUNCTION _Maklocchr
#define _MAKLOCCHR(Elem, chr, cvt) \
	_Maklocchr(chr, (Elem *)0, cvt)	/* convert char to Elem */

template<class _Elem> inline
	_Elem __CRTDECL _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert char to _Elem using _Cvtvec
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __CRTDECL _Maklocchr(char _Byte, __in_z_opt wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert char to wchar_t using _Cvtvec
	wchar_t _Wc = L'\0';
	_Mbstinit(_Mbst1);
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 #ifdef _CRTBLD_NATIVE_WCHAR_T
template<> inline
	unsigned short __CRTDECL _Maklocchr(char _Byte, __in_opt unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	// convert char to unsigned short using _Cvtvec
	unsigned short _Wc = (unsigned short)0;
	_Mbstinit(_Mbst1);
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #endif /* _CRTBLD_NATIVE_WCHAR_T */

		// TEMPLATE FUNCTION _Maklocstr
#define _MAKLOCSTR(_Elem, _Str, _Cvt)	\
	_Maklocstr(_Str, (_Elem *)0, _Cvt)	// convert C string to _Elem sequence

template<class _Elem> inline
	_Elem *__CRTDECL _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	// convert C string to _Elem sequence using _Cvtvec
	size_t _Count = ::strlen(_Ptr) + 1;
	_Elem *_Ptrdest = _NEW_CRT _Elem[_Count];

#pragma warning(push)
#pragma warning(disable: 6011)
	/* prefast noise */
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
	return (_Ptrdest);
#pragma warning(pop)
	}

template<> inline
	wchar_t *__CRTDECL _Maklocstr(const char *_Ptr, __in_z_opt wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	// convert C string to wchar_t sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	_Mbstinit(_Mbst1);

	_Count1 = ::strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	_Mbstinit(_Mbst2);
#pragma warning(push)
#pragma warning(disable: 6011)
	/* prefast noise */
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
#pragma warning(pop)
	return (_Ptrdest);
	}

 #ifdef _CRTBLD_NATIVE_WCHAR_T
template<> inline
	unsigned short *__CRTDECL _Maklocstr(const char *_Ptr, 
		__in_opt unsigned short *, const _Locinfo::_Cvtvec& _Cvt)
	{	// convert C string to unsigned short sequence using _Cvtvec
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	_Mbstinit(_Mbst1);

	_Count1 = ::strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	// count terminating nul

	wchar_t *_Ptrdest = _NEW_CRT wchar_t[_Wchars];
	wchar_t *_Ptrnext = _Ptrdest;
	_Mbstinit(_Mbst2);
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #endif /* _CRTBLD_NATIVE_WCHAR_T */

		// STRUCT codecvt_base
class _CRTIMP2_PURE codecvt_base
	: public locale::facet
	{	// base class for codecvt
public:
	enum
		{	// constants for different parse states
		ok, partial, error, noconv};
	typedef int result;

	__CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	bool __CLR_OR_THIS_CALL always_noconv() const _THROW0()
		{	// return true if conversions never change input (from codecvt)
		return (do_always_noconv());
		}

	int __CLR_OR_THIS_CALL max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (do_max_length());
		}

	int __CLR_OR_THIS_CALL encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (do_encoding());
		}

	__CLR_OR_THIS_CALL ~codecvt_base()
		{	// destroy the object
		}

protected:
	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
		{	// return true if conversions never change input (from codecvt)
		return (true);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (1);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (1);	// -1 ==> state dependent, 0 ==> varying length
		}
	};

		// TEMPLATE CLASS codecvt
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	// facet for converting between _Elem and char (_Byte) sequences
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last2)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>;
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~codecvt()
		{	// destroy the object
		}

protected:
	void __CLR_OR_THIS_CALL _Init(const _Locinfo&)
		{	// initialize from _Locinfo object
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype&,
		const _Byte *_First1, const _Byte *, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);	// convert nothing
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype&,
		const _Elem *_First1, const _Elem *, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_Mid1 = _First1, _Mid2 = _First2;
		return (noconv);	// convert nothing
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	// generate bytes to return to default shift state
		_Mid2 = _First2;
		return (noconv);	// convert nothing
		}

	virtual int __CLR_OR_THIS_CALL do_length(const _Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	// assume 1-to-1 conversion
		}
	};

		// STATIC codecvt::id OBJECT
template<class _Elem,
	class _Byte,
	class _Statype>
	__PURE_APPDOMAIN_GLOBAL locale::id codecvt<_Elem, _Byte, _Statype>::id;

		// CLASS codecvt<wchar_t, char, _Mbstatet>
template<> class _CRTIMP2_PURE codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between wchar_t and char (_Byte) sequences
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	static _MRTIMP2_NPURE locale::id& __cdecl _Id_func();
#ifdef _M_CEE_PURE
	static locale::id& id;	// unique facet id
#else
	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
#endif

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>;
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~codecvt()
		{	// destroy the object
		}

protected:
	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	// failed conversion
				return (error);

			case 0:	// may have converted null character
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int)::strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to a wchar_t
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if (MB_LEN_MAX <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	// locale-specific wcrtomb failed
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	// destination possibly too small, convert into buffer
				_Byte _Buf[MB_LEN_MAX];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	// locale-specific wcrtomb failed
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	// copy converted bytes from buffer
					_CRT_SECURE_MEMCPY(_Mid2, _Last2 - _Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_DEBUG_RANGE(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[MB_LEN_MAX];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	// locale-specific wcrtomb failed
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			_CRT_SECURE_MEMCPY(_Mid2, _Last2 - _Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int __CLR_OR_THIS_CALL do_length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		_DEBUG_RANGE(_First1, _Last1);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	// convert another wchar_t
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				return (_Wchars);

			case -1:	// failed conversion
				return (_Wchars);

			case 0:	// may have converted null character
				if (_Ch == (_Elem)0)
					_Bytes = (int)::strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to a wchar_t
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
		{	// return true if conversions never change input
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (MB_LEN_MAX);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (0);
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};

#ifdef _NATIVE_WCHAR_T_DEFINED
		// CLASS codecvt<unsigned short, char, _Mbstatet>
template<> class _CRTIMP2_PURE codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	// facet for converting between unsigned short and char sequences
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result __CLR_OR_THIS_CALL in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result __CLR_OR_THIS_CALL unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int __CLR_OR_THIS_CALL length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		return (do_length(_State, _First1, _Last1, _Count));
		}

	static _MRTIMP2_NPURE locale::id& __cdecl _Id_func();
#ifdef _M_CEE_PURE
	static locale::id& id;	// unique facet id
#else
	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
#endif

	explicit __CLR_OR_THIS_CALL codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT codecvt<_Elem, _Byte, _Statype>;
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~codecvt()
		{	// destroy the object
		}

protected:
	__CLR_OR_THIS_CALL codecvt(const char *_Locname, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	// construct from specified locale
		_BEGIN_LOCINFO(_Lobj(_Locname))
			_Init(_Lobj);
		_END_LOCINFO()
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Cvt = _Lobj._Getcvt();
		}

	virtual result __CLR_OR_THIS_CALL do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	// convert bytes [_First1, _Last1) to [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	// failed conversion
				return (error);

			case 0:	// may have converted null character
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int)::strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to an unsigned short
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result __CLR_OR_THIS_CALL do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// convert [_First1, _Last1) to bytes [_First2, _Last)
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_RANGE(_First2, _Last2);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if (MB_LEN_MAX <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	// locale-specific wcrtomb failed
				else
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
			else
				{	// destination possibly too small, convert into buffer
				_Byte _Buf[MB_LEN_MAX];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	// locale-specific wcrtomb failed
				else if (_Last2 - _Mid2 < _Bytes)
					{	// converted too many, roll back and return previous
					_State = _Stsave;
					return (_Ans);
					}
				else
					{	// copy converted bytes from buffer
					_CRT_SECURE_MEMCPY(_Mid2, _Last2 - _Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes, _Ans = ok;
					}
				}
		return (_Ans);
		}

	virtual result __CLR_OR_THIS_CALL do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	// generate bytes to return to default shift state
		_DEBUG_RANGE(_First2, _Last2);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[MB_LEN_MAX];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	// locale-specific wcrtomb failed
		else if (_Last2 - _Mid2 < --_Bytes)
			{	// converted too many, roll back and return
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	// copy converted bytes from buffer
			_CRT_SECURE_MEMCPY(_Mid2, _Last2 - _Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int __CLR_OR_THIS_CALL do_length(const _Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	// return min(_Count, converted length of bytes [_First1, _Last1))
		_DEBUG_RANGE(_First1, _Last1);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	// convert another unsigned char
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	// test result of locale-specific mbrtowc call
			case -2:	// partial conversion
				return (_Wchars);

			case -1:	// failed conversion
				return (_Wchars);

			case 0:	// may have converted null character
				if (_Ch == (_Elem)0)
					_Bytes = (int)::strlen(_Mid1) + 1;
				// fall through

			default:	// converted _Bytes bytes to an unsigned char
				if (_Bytes == -3)
					_Bytes = 0;	// wchar_t generated from state info
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool __CLR_OR_THIS_CALL do_always_noconv() const _THROW0()
		{	// return true if conversions never change input
		return (false);
		}

	virtual int __CLR_OR_THIS_CALL do_max_length() const _THROW0()
		{	// return maximum length required for a conversion (from codecvt)
		return (MB_LEN_MAX);
		}

	virtual int __CLR_OR_THIS_CALL do_encoding() const _THROW0()
		{	// return length of code sequence (from codecvt)
		return (0);
		}

private:
	_Locinfo::_Cvtvec _Cvt;	// locale info passed to _Mbrtowc, _Wcrtomb
	};
#endif /* _NATIVE_WCHAR_T_DEFINED */

		// TEMPLATE CLASS codecvt_byname
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	// codecvt for named locale
public:
	explicit __CLR_OR_THIS_CALL codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locname, _Refs)
		{	// construct for named locale
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~codecvt_byname()
		{	// destroy the object
		}
	};

		// STRUCT ctype_base
struct _CRTIMP2_PURE ctype_base
	: public locale::facet
	{	// base for ctype
	enum
		{	// constants for character classifications
		alnum = _DI|_LO|_UP|_XA, alpha = _LO|_UP|_XA,
		cntrl = _BB, digit = _DI, graph = _DI|_LO|_PU|_UP|_XA,
		lower = _LO, print = _DI|_LO|_PU|_SP|_UP|_XA|_XD,
		punct = _PU, space = _CN|_SP|_XS, upper = _UP,
		xdigit = _XD};
	typedef short mask;	// to match <ctype.h>

	__CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	// default constructor
		}

	__CLR_OR_THIS_CALL ~ctype_base()
		{	// destroy the object
		}

_PROTECTED:
#ifndef MRTDLL
	static void __CLRCALL_OR_CDECL _Xran()
		{	// report an out_of_range error
		_THROW(out_of_range, "out_of_range in ctype<T>");
		}
#endif
	};

		// TEMPLATE CLASS ctype
template<class _Elem>
	class ctype
		: public ctype_base
	{	// facet for classifying elements, converting cases
public:
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	_SCL_INSECURE_DEPRECATE
	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const char *__CLR_OR_THIS_CALL _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in the destination buffer
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem *__CLR_OR_THIS_CALL _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount_part(_Dest_size, _Last-_First) char *_Dest, size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id

	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>;
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~ctype()
		{	// destroy the object
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		}

	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to lower case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			{	// convert *_First to upper case
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_MAKLOCCHR(_Elem, _Byte, _Cvt));
		}

	_SCL_INSECURE_DEPRECATE
	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const char *__CLR_OR_THIS_CALL _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _MAKLOCCHR(_Elem, *_First, _Cvt);
		return (_First);
		}

	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _MAKLOCBYTE(_Elem, _Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, __out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		__out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

		// STATIC ctype::id OBJECT
template<class _Elem>
	__PURE_APPDOMAIN_GLOBAL locale::id ctype<_Elem>::id;

		// CLASS ctype<char>
template<> class _CRTIMP2_PURE ctype<char>
	: public ctype_base
	{	// facet for classifying char elements, converting cases
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	_SCL_INSECURE_DEPRECATE
	const _Elem *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const _Elem *__CLR_OR_THIS_CALL _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	_Elem __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem *__CLR_OR_THIS_CALL _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	static _MRTIMP2_NPURE locale::id& __cdecl _Id_func();
#ifdef _M_CEE_PURE
	static locale::id& id;	// unique facet id
#else
	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
#endif

	explicit __CLR_OR_THIS_CALL ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct with specified table and delete flag for table
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		if (_Table != 0)
			{	// replace existing char to mask table
			_Tidy();
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// construct from specified locale
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>;
		return (_X_CTYPE);
		}

	_PGLOBAL static const size_t table_size = 1 << 8/*CHAR_BIT*/;	// size of _Ctype._Table (char to mask)

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~ctype()
		{	// destroy the object
		_Tidy();
		}

protected:
	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		}

	void __CLR_OR_THIS_CALL _Tidy()
		{	// free any allocated storage
		if (0 < _Ctype._Delfl)
			free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] (void *)_Ctype._Table;
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_Byte);
		}

	_SCL_INSECURE_DEPRECATE
	virtual const _Elem *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const
		{	// narrow char
		return (_Ch);
		}

	_SCL_INSECURE_DEPRECATE
	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		__out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char, __out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		_CRT_SECURE_MEMCPY(_Dest, _Dest_size, _First, _Last - _First);
		return (_Last);
		}

	const mask *__CLR_OR_THIS_CALL table() const _THROW0()
		{	// return address of char to mask table
		return (_Ctype._Table);
		}

	static const mask *__CLRCALL_OR_CDECL classic_table() _THROW0()
		{	// return address of char to mask table for "C" locale
		const _Myt& _Ctype_fac = _USE(locale::classic(), _Myt);
		return (_Ctype_fac.table());
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// information
	};

		// CLASS ctype<wchar_t>
template<> class _CRTIMP2_PURE ctype<wchar_t>
	: public ctype_base
	{	// facet for classifying wchar_t elements, converting cases
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	_SCL_INSECURE_DEPRECATE
	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const char *__CLR_OR_THIS_CALL _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem *__CLR_OR_THIS_CALL _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	static _MRTIMP2_NPURE locale::id& __cdecl _Id_func();
#ifdef _M_CEE_PURE
	static locale::id& id;	// unique facet id
#else
	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
#endif

	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>;
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~ctype()
		{	// destroy the object
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const wchar_t *__CLR_OR_THIS_CALL do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		return (::_Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const
		{	// widen char
		_Mbstinit(_Mbst);
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)WEOF : _Wc);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	_SCL_INSECURE_DEPRECATE
	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const char *__CLR_OR_THIS_CALL _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[MB_LEN_MAX];
		_Mbstinit(_Mbst);
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt,  
		__out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		__out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};

#ifdef _NATIVE_WCHAR_T_DEFINED
		// CLASS ctype<unsigned short>
template<> class _CRTIMP2_PURE ctype<unsigned short>
	: public ctype_base
	{	// facet for classifying unsigned short elements, converting cases
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return (do_is(_Maskval, _Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem *__CLR_OR_THIS_CALL scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (do_tolower(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL tolower(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		return (do_tolower(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (do_toupper(_Ch));
		}

	const _Elem *__CLR_OR_THIS_CALL toupper(_Elem *_First, const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		return (do_toupper(_First, _Last));
		}

	_Elem __CLR_OR_THIS_CALL widen(char _Byte) const
		{	// widen char
		return (do_widen(_Byte));
		}

	_SCL_INSECURE_DEPRECATE
	const char *__CLR_OR_THIS_CALL widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_widen(_First, _Last, _Dest));
#pragma warning(pop)
		}

	const char *__CLR_OR_THIS_CALL _Widen_s(const char *_First, const char *_Last,
		_Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		return (_Do_widen_s(_First, _Last, _Dest, _Dest_size));
		}

	char __CLR_OR_THIS_CALL narrow(_Elem _Ch, char _Dflt = '\0') const
		{	// narrow element to char
		return (do_narrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	const _Elem *__CLR_OR_THIS_CALL narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
#pragma warning(push)
#pragma warning(disable:4996)
		return (do_narrow(_First, _Last, _Dflt, _Dest));
#pragma warning(pop)
		}

	const _Elem *__CLR_OR_THIS_CALL _Narrow_s(const _Elem *_First, const _Elem *_Last,
		char _Dflt, __out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		return (_Do_narrow_s(_First, _Last, _Dflt, _Dest, _Dest_size));
		}

	static _MRTIMP2_NPURE locale::id& __cdecl _Id_func();
#ifdef _M_CEE_PURE
	static locale::id& id;	// unique facet id
#else
	__PURE_APPDOMAIN_GLOBAL static locale::id id;	// unique facet id
#endif

	explicit __CLR_OR_THIS_CALL ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from current locale
		_BEGIN_LOCINFO(_Lobj)
			_Init(_Lobj);
		_END_LOCINFO()
		}

	__CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_Init(_Lobj);
		}

	static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet **_Ppf = 0)
		{	// return locale category mask and construct standard facet
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = _NEW_CRT ctype<_Elem>;
		return (_X_CTYPE);
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~ctype()
		{	// destroy the object
		if (_Ctype._Delfl)
			free((void *)_Ctype._Table);
		}

protected:
	__CLR_OR_THIS_CALL ctype(const char *_Locname, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	// construct from specified locale
		_BEGIN_LOCINFO(_Lobj(_Locname))
			_Init(_Lobj);
		_END_LOCINFO()
		}

	void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj)
		{	// initialize from _Lobj
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool __CLR_OR_THIS_CALL do_is(mask _Maskval, _Elem _Ch) const
		{	// test if element fits any mask classifications
		return ((::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	// get mask sequence for elements in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		return ((const _Elem *)::_Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) that fits mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	// find first in [_First, _Last) not fitting mask classification
		_DEBUG_RANGE(_First, _Last);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const
		{	// convert element to lower case
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to lower case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const
		{	// convert element to upper case
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem *__CLR_OR_THIS_CALL do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	// convert [_First, _Last) in place to upper case
		_DEBUG_RANGE((const _Elem *)_First, _Last);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const
		{	// widen char
		_Mbstinit(_Mbst);
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)WEOF : _Wc);
		}

	virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const
		{	// widen char
		return (_Dowiden(_Byte));
		}

	_SCL_INSECURE_DEPRECATE
	virtual const char *__CLR_OR_THIS_CALL do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	// widen chars in [_First, _Last)
		// assume there is enough space in _Dest
		return _Do_widen_s(_First, _Last, _Dest, _Last - _First);
		}

	virtual const char *__CLR_OR_THIS_CALL _Do_widen_s(const char *_First,
		const char *_Last, _Elem *_Dest, size_t _Dest_size) const
		{	// widen chars in [_First, _Last)
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		char _Buf[MB_LEN_MAX];
		_Mbstinit(_Mbst);
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const
		{	// narrow element to char
		return (_Donarrow(_Ch, _Dflt));
		}

	_SCL_INSECURE_DEPRECATE
	virtual const _Elem *__CLR_OR_THIS_CALL do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, __out_ecount(_Last-_First) char *_Dest) const
		{	// narrow elements in [_First, _Last) to chars
		// assume there is enough space in _Dest
		return _Do_narrow_s(_First, _Last, _Dflt, _Dest, _Last - _First);
		}

	virtual const _Elem *__CLR_OR_THIS_CALL _Do_narrow_s(const _Elem *_First,
		const _Elem *_Last, char _Dflt, 
		__out_ecount_part(_Dest_size, _Last-_First) char *_Dest, 
		size_t _Dest_size) const
		{	// narrow elements in [_First, _Last) to chars
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		_SCL_SECURE_ALWAYS_VALIDATE_RANGE(_Dest_size >= (size_t)(_Last - _First));
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	// locale info passed to _Tolower, etc.
	_Locinfo::_Cvtvec _Cvt;		// conversion information
	};
#endif /* _NATIVE_WCHAR_T_DEFINED */

#ifndef MRTDLL
		// TEMPLATE CLASS ctype_byname
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	// ctype for named locale
public:
	explicit __CLR_OR_THIS_CALL ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locname, _Refs)
		{	// construct from named locale
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~ctype_byname()
		{	// destroy the object
		}
	};

		// TEMPLATE CLASS ctype_byname<char>
template<> class ctype_byname<char>
	: public ctype<char>
	{	// ctype_byname<char> for named locale
public:
	explicit __CLR_OR_THIS_CALL ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locname, _Refs)
		{	// construct from named locale
		}

_PROTECTED:
	virtual __CLR_OR_THIS_CALL ~ctype_byname()
		{	// destroy the object
		}
	};
#endif

 #if defined(_DLL_CPPLIB) && !defined(_M_CEE_PURE)

  #ifdef __FORCE_INSTANCE
template class _CRTIMP2_PURE codecvt<char, char, _Mbstatet>;
  #endif /* __FORCE_INSTANCE */

 #endif /* _DLL_CPPLIB */
_STD_END

#ifdef  _MSC_VER
#pragma warning(pop)
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* RC_INVOKED */
#endif /* _XLOCALE_ */

/*
 * Copyright (c) 1992-2005 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V4.05:0009 */
