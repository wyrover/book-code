#ifndef _PACKET_H
#define _PACKET_H 1

#if DBG
#define dprintf DbgPrint
#else
static void dprintf(void* _fmt, ...) {}
#endif

#define nprintf DbgPrint

#ifndef MIN
#define MIN(_a, _b) ((_a) < (_b)? (_a): (_b))
#endif

#if DBG
#define NUIO_REF_OPEN(_pOpen)   ndisuioDbgRefOpen(_pOpen, __FILE__, __LINE__)
#define NUIO_DEREF_OPEN(_pOpen) ndisuioDbgDerefOpen(_pOpen, __FILE__, __LINE__)
#else
#if 1
#define NUIO_REF_OPEN(_pOpen)	NdisInterlockedIncrement(&_pOpen->RefCount)
#define NUIO_DEREF_OPEN(_pOpen) \
	{ \
		if (NdisInterlockedDecrement(&_pOpen->RefCount) == 0) \
			NUIO_FREE_MEM(pOpenContext); \
	}
#else
#define NUIO_REF_OPEN(_pOpen)   ndisuioRefOpen(_pOpen)
#define NUIO_DEREF_OPEN(_pOpen) ndisuioDerefOpen(_pOpen)
#endif
#endif

//
//  Spinlock macros
//
#if DBG_SPIN_LOCK

#define NUIO_INIT_LOCK(_pLock)              \
           ndisuioAllocateSpinLock(_pLock, __FILE__, __LINE__)

#define NUIO_ACQUIRE_LOCK(_pLock)           \
            ndisuioAcquireSpinLock(_pLock, __FILE__, __LINE__)

#define NUIO_RELEASE_LOCK(_pLock)           \
            ndisuioReleaseSpinLock(_pLock, __FILE__, __LINE__)

#else

#define NUIO_INIT_LOCK(_pLock)           NdisAllocateSpinLock(_pLock)
#define NUIO_ACQUIRE_LOCK(_pLock)        NdisAcquireSpinLock(_pLock)
#define NUIO_RELEASE_LOCK(_pLock)        NdisReleaseSpinLock(_pLock)

#endif // DBG

//
//  List manipulation.
//
#define NUIO_INIT_LIST_HEAD(_pList)             InitializeListHead(_pList)
#define NUIO_IS_LIST_EMPTY(_pList)              IsListEmpty(_pList)
#define NUIO_INSERT_HEAD_LIST(_pList, _pEnt)    InsertHeadList(_pList, _pEnt)
#define NUIO_INSERT_TAIL_LIST(_pList, _pEnt)    InsertTailList(_pList, _pEnt)
#define NUIO_REMOVE_ENTRY_LIST(_pEnt)           RemoveEntryList(_pEnt)

//
//  Receive packet queueing.
//
#define NUIO_LIST_ENTRY_TO_RCV_PKT(_pEnt)   \
    CONTAINING_RECORD(CONTAINING_RECORD(_pEnt, NUIO_RECV_PACKET_RSVD, Link), NDIS_PACKET, ProtocolReserved)

#define NUIO_RCV_PKT_TO_LIST_ENTRY(_pPkt)   \
    (&((PNUIO_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->Link)

//
//  In case we allocate a receive packet of our own to copy and queue
//  received data, we might have to also allocate an auxiliary NDIS_BUFFER
//  to map part of the receive buffer (skipping the header bytes), so as
//  to satisfy NdisTransferData. In such cases, we keep a pointer to the
//  fully mapped receive buffer in the packet reserved space:
//
#define NUIO_RCV_PKT_TO_ORIGINAL_BUFFER(_pPkt)  \
    (((PNUIO_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pOriginalBuffer)

#define NUIO_IRP_FROM_RCV_PKT(_pPkt)		\
	(((PNUIO_RECV_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pIrp)

//
//  Send packet context.
//
#define NUIO_IRP_FROM_SEND_PKT(_pPkt)		\
	(((PNUIO_SEND_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))->pIrp)

#define NUIO_SEND_PKT_RSVD(_pPkt)           \
    ((PNUIO_SEND_PACKET_RSVD)&((_pPkt)->ProtocolReserved[0]))

#define NUIO_REF_SEND_PKT(_pPkt)            \
    (VOID)NdisInterlockedIncrement(&NUIO_SEND_PKT_RSVD(_pPkt)->RefCount)

#define NUIO_DEREF_SEND_PKT(_pPkt)          \
    {                                                                               \
        if (NdisInterlockedDecrement(&NUIO_SEND_PKT_RSVD(_pPkt)->RefCount) == 0)    \
        {                                                                           \
            NdisFreePacket(_pPkt);                                                  \
        }                                                                           \
    }


#ifdef NDIS51

//
//  Cancel IDs are generated by using the partial cancel ID we got from
//  NDIS ORed with a monotonically increasing locally generated ID.
//
#define NUIO_CANCEL_ID_LOW_MASK     (((ULONG_PTR)-1) >> 8) 

#define NUIO_GET_NEXT_CANCEL_ID()                                                   \
        (PVOID)(Globals.PartialCancelId |                                           \
         ((NdisInterlockedIncrement(&Globals.LocalCancelId)) & NUIO_CANCEL_ID_LOW_MASK))

#endif // NDIS51

//
//  Memory allocation
//
#if DBG
#define NUIO_ALLOC_MEM(_pVar, _Size)        \
    (_pVar) = ndisuioAuditAllocMem(&(_pVar), _Size, __FILE__, __LINE__);

#define NUIO_FREE_MEM(_pMem)                \
    ndisuioAuditFreeMem(_pMem);

#else

// I don't use NdisAllocateMemoryWithTag here, because it's only a wrapper.
#define NUIO_ALLOC_MEM(_pVar, _Size)        \
    _pVar = ExAllocatePoolWithTag(NonPagedPool, (_Size), 'P5DN')

#define NUIO_FREE_MEM(_pMem)                \
    ExFreePool(_pMem)

#endif // DBG

#define NUIO_ZERO_MEM(_pMem, _ByteCount)        \
    NdisZeroMemory(_pMem, _ByteCount)

#define NUIO_COPY_MEM(_pDst, _pSrc, _ByteCount) \
    NdisMoveMemory(_pDst, _pSrc, _ByteCount)

#define NUIO_MEM_CMP(_p1, _p2, _ByteCount)      \
    NdisEqualMemory(_p1, _p2, _ByteCount)

#define NUIO_SET_MEM(_pMem, _ByteVal, _ByteCount)   \
    NdisFillMemory(_pMem, _ByteCount, _ByteVal)

//
//  Events.
//
#define NUIO_INIT_EVENT(_pEvent)            NdisInitializeEvent(_pEvent)
#define NUIO_SIGNAL_EVENT(_pEvent)          NdisSetEvent(_pEvent)
#define NUIO_WAIT_EVENT(_pEvent, _MsToWait) NdisWaitEvent(_pEvent, _MsToWait)

//
//  Flags
//
#define NUIO_SET_FLAGS(_FlagsVar, _Mask, _BitsToSet)    \
        (_FlagsVar) = ((_FlagsVar) & ~(_Mask)) | (_BitsToSet)

#define NUIO_TEST_FLAGS(_FlagsVar, _Mask, _BitsToCheck)    \
        (((_FlagsVar) & (_Mask)) == (_BitsToCheck))

//
//  Block the calling thread for the given duration:
//
#define NUIO_SLEEP(_Seconds)                            \
{                                                       \
    NDIS_EVENT  _SleepEvent;                            \
    NdisInitializeEvent(&_SleepEvent);                  \
    (VOID)NdisWaitEvent(&_SleepEvent, _Seconds*1000);   \
}

#define NDIS_STATUS_TO_NT_STATUS(_NdisStatus, _pNtStatus)                           \
{                                                                                   \
    /*                                                                              \
     *  The following NDIS status codes map directly to NT status codes.            \
     */                                                                             \
    if (((NDIS_STATUS_SUCCESS == (_NdisStatus)) ||                                  \
        (NDIS_STATUS_PENDING == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_BUFFER_OVERFLOW == (_NdisStatus)) ||                           \
        (NDIS_STATUS_FAILURE == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_RESOURCES == (_NdisStatus)) ||                                 \
        (NDIS_STATUS_NOT_SUPPORTED == (_NdisStatus))))                              \
    {                                                                               \
        *(_pNtStatus) = (NTSTATUS)(_NdisStatus);                                    \
    }                                                                               \
    else if (NDIS_STATUS_BUFFER_TOO_SHORT == (_NdisStatus))                         \
    {                                                                               \
        /*                                                                          \
         *  The above NDIS status codes require a little special casing.            \
         */                                                                         \
        *(_pNtStatus) = STATUS_BUFFER_TOO_SMALL;                                    \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_LENGTH == (_NdisStatus))                           \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_BUFFER_SIZE;                                 \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_DATA == (_NdisStatus))                             \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_PARAMETER;                                   \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_FOUND == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_NO_MORE_ENTRIES;                                     \
    }                                                                               \
    else if (NDIS_STATUS_ADAPTER_NOT_READY == (_NdisStatus))                        \
    {                                                                               \
        *(_pNtStatus) = STATUS_DEVICE_NOT_READY;                                    \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        *(_pNtStatus) = STATUS_UNSUCCESSFUL;                                        \
    }                                                                               \
}

//
// Message verbosity: lower values indicate higher urgency
//
#define DL_EXTRA_LOUD       20
#define DL_VERY_LOUD        10
#define DL_LOUD             8
#define DL_INFO             6
#define DL_WARN             4
#define DL_ERROR            2
#define DL_FATAL            0

#if DBG_SPIN_LOCK

typedef struct _NUIO_LOCK
{
    ULONG                   Signature;
    ULONG                   IsAcquired;
    PKTHREAD                OwnerThread;
    ULONG                   TouchedByFileNumber;
    ULONG                   TouchedInLineNumber;
    NDIS_SPIN_LOCK          NdisLock;
} NUIO_LOCK, *PNUIO_LOCK;

#define NUIOL_SIG    'KCOL'

extern NDIS_SPIN_LOCK       ndisuioDbgLogLock;

extern
VOID
ndisuioAllocateSpinLock(
    IN  PNUIO_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
ndisuioAcquireSpinLock(
    IN  PNUIO_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

extern
VOID
ndisuioReleaseSpinLock(
    IN  PNUIO_LOCK          pLock,
    IN  ULONG               FileNumber,
    IN  ULONG               LineNumber
);

#define CHECK_LOCK_COUNT(Count)                                         \
            {                                                           \
                if ((INT)(Count) < 0)                                   \
                {                                                       \
                    DbgPrint("Lock Count %d is < 0! File %s, Line %d\n",\
                        Count, __FILE__, __LINE__);                     \
                    DbgBreakPoint();                                    \
                }                                                       \
            }
#else

#define CHECK_LOCK_COUNT(Count)

typedef NDIS_SPIN_LOCK      NUIO_LOCK;
typedef PNDIS_SPIN_LOCK     PNUIO_LOCK;

#endif    // DBG_SPIN_LOCK

#if DBG

extern INT                ndisuioDebugLevel;

#define DEBUGP(lev, stmt)                                               \
        {                                                               \
            if ((lev) <= ndisuioDebugLevel)                             \
            {                                                           \
            }                                                           \
        }

#define DEBUGPDUMP(lev, pBuf, Len)                                      \
        {                                                               \
            if ((lev) <= ndisuioDebugLevel)                             \
            {                                                           \
                DbgPrintHexDump((PUCHAR)(pBuf), (ULONG)(Len));          \
            }                                                           \
        }

#define NUIO_ASSERT(exp)                                                \
        {                                                               \
            if (!(exp))                                                 \
            {                                                           \
                                                                        \
                                                                        \
                DbgBreakPoint();                                        \
            }                                                           \
        }

#define NUIO_SET_SIGNATURE(s, t)\
        (s)->t##_sig = t##_signature;

#define NUIO_STRUCT_ASSERT(s, t)                                        \
        if ((s)->t##_sig != t##_signature)                              \
        {                                                               \
            DbgBreakPoint();                                            \
        }

//
// Memory Allocation/Freeing Audit:
//

//
// The NUIOD_ALLOCATION structure stores all info about one allocation
//
typedef struct _NUIOD_ALLOCATION
{
	ULONG                    Signature;
	struct _NUIOD_ALLOCATION *Next;
	struct _NUIOD_ALLOCATION *Prev;
	LPCSTR					 FileName;
	ULONG                    LineNumber;
	ULONG                    Size;
	PVOID					 Location;  // where the returned ptr was stored
	union
	{
		ULONGLONG            Alignment;
		UCHAR				 UserData;
	};	
} NUIOD_ALLOCATION, *PNUIOD_ALLOCATION;

#define NUIOD_MEMORY_SIGNATURE    (ULONG)'CSII'

extern
PVOID
ndisuioAuditAllocMem(
    PVOID		pPointer,
    ULONG		Size,
    LPCSTR		pFilename,
    ULONG		LineNumber
	);

extern
VOID
ndisuioAuditFreeMem(
    PVOID        Pointer
	);

extern
VOID
ndisuioAuditShutdown(
    VOID
	);

extern
VOID
DbgPrintHexDump(
    PUCHAR		pBuffer,
    ULONG		Length
	);

#else

//
// No debug
//
#define DEBUGP(lev, stmt)
#define DEBUGPDUMP(lev, pBuf, Len)

#define NUIO_ASSERT(exp)
#define NUIO_SET_SIGNATURE(s, t)
#define NUIO_STRUCT_ASSERT(s, t)

#endif    // DBG

#ifdef WIN9X
#undef NdisGetPoolFromPacket
#define NdisGetPoolFromPacket(_Pkt) ((_Pkt)->Private.Pool)
#endif

#define NUIO_MAC_ADDR_LEN		6

//
//  The Open Context represents an open of our device object.
//  We allocate this on processing a BindAdapter from NDIS,
//  and free it when all references (see below) to it are gone.
//
//  Binding/unbinding to an NDIS device:
//
//  On processing a BindAdapter call from NDIS, we set up a binding
//  to the specified NDIS device (miniport). This binding is
//  torn down when NDIS asks us to Unbind by calling
//  our UnbindAdapter handler.
//
//  Receiving data:
//
//  While an NDIS binding exists, read IRPs are queued on this
//  structure, to be processed when packets are received.
//  If data arrives in the absense of a pended read IRP, we
//  queue it, to the extent of one packet, i.e. we save the
//  contents of the latest packet received. We fail read IRPs
//  received when no NDIS binding exists (or is in the process
//  of being torn down).
//
//  Sending data:
//
//  Write IRPs are used to send data. Each write IRP maps to
//  a single NDIS packet. Packet send-completion is mapped to
//  write IRP completion. We use NDIS 5.1 CancelSend to support
//  write IRP cancellation. Write IRPs that arrive when we don't
//  have an active NDIS binding are failed.
//
//  Reference count:
//
//  The following are long-lived references:
//  OPEN_DEVICE ioctl (goes away on processing a Close IRP)
//  Pended read IRPs
//  Queued received packets
//  Uncompleted write IRPs (outstanding sends)
//  Existence of NDIS binding
//
typedef struct _NDISUIO_OPEN_CONTEXT
{
    LIST_ENTRY              Link;           // Link into global list
    ULONG                   Flags;          // State information
    ULONG                   RefCount;
    NUIO_LOCK               Lock;

    PFILE_OBJECT            pFileObject;    // Set on OPEN_DEVICE

    NDIS_HANDLE             BindingHandle;
    NDIS_HANDLE             SendPacketPool;
    NDIS_HANDLE             SendBufferPool;
    NDIS_HANDLE             RecvPacketPool;
    NDIS_HANDLE             RecvBufferPool;
    ULONG                   MacOptions;
    ULONG                   MaxFrameSize;

    LIST_ENTRY              PendedWrites;   // pended Write IRPs
    ULONG                   PendedSendCount;

    LIST_ENTRY              PendedReads;    // pended Read IRPs
    ULONG                   PendedReadCount;
    LIST_ENTRY              RecvPktQueue;   // queued rcv packets
    ULONG                   RecvPktCount;

    NET_DEVICE_POWER_STATE  PowerState;
    NDIS_EVENT              PoweredUpEvent; // signalled iff PowerState is D0
    NDIS_STRING             DeviceName;     // used in NdisOpenAdapter
    NDIS_STRING				DeviceDescr;	// friendly name

    NDIS_STATUS             BindStatus;     // for Open/CloseAdapter
    NDIS_EVENT              BindEvent;      // for Open/CloseAdapter

    BOOLEAN                 bRunningOnWin9x;// TRUE if Win98/SE/ME, FALSE if NT

    ULONG                   oc_sig;         // Signature for sanity

    UCHAR                   CurrentAddress[NUIO_MAC_ADDR_LEN];

	LONGLONG				DroppedPackets;
	LONGLONG				ReceivedPackets;
} NDISUIO_OPEN_CONTEXT, *PNDISUIO_OPEN_CONTEXT;

#define oc_signature        'Tkp5'

//
//  Definitions for Flags above.
//
#define NUIOO_BIND_IDLE             0x00000000
#define NUIOO_BIND_OPENING          0x00000001
#define NUIOO_BIND_FAILED           0x00000002
#define NUIOO_BIND_ACTIVE           0x00000004
#define NUIOO_BIND_CLOSING          0x00000008
#define NUIOO_BIND_FLAGS            0x0000000F  // State of the binding

#define NUIOO_OPEN_IDLE             0x00000000
#define NUIOO_OPEN_ACTIVE           0x00000010
#define NUIOO_OPEN_FLAGS            0x000000F0  // State of the I/O open

#define NUIOO_RESET_IN_PROGRESS     0x00000100
#define NUIOO_NOT_RESETTING         0x00000000
#define NUIOO_RESET_FLAGS           0x00000100

#define NUIOO_MEDIA_CONNECTED       0x00000000
#define NUIOO_MEDIA_DISCONNECTED    0x00000200
#define NUIOO_MEDIA_FLAGS           0x00000200

#define NUIOO_READ_SERVICING        0x00100000  // Is the read service
                                                // routine running?
#define NUIOO_READ_FLAGS            0x00100000

#define NUIOO_UNBIND_RECEIVED       0x10000000  // Seen NDIS Unbind?
#define NUIOO_UNBIND_FLAGS          0x10000000


//
//  Globals:
//
typedef struct _NDISUIO_GLOBALS
{
    PDRIVER_OBJECT          pDriverObject;
    PDEVICE_OBJECT          ControlDeviceObject;
    NDIS_HANDLE             NdisProtocolHandle;
    UCHAR                   PartialCancelId;    // for cancelling sends
    ULONG                   LocalCancelId;
    LIST_ENTRY              OpenList;           // of OPEN_CONTEXT structures
    NUIO_LOCK               GlobalLock;         // to protect the above
    NDIS_EVENT              BindsComplete;      // have we seen NetEventBindsComplete?
} NDISUIO_GLOBALS, *PNDISUIO_GLOBALS;

//
//  NDIS Request context structure
//
typedef struct _NDISUIO_REQUEST
{
    NDIS_REQUEST            Request;
    NDIS_EVENT              ReqEvent;
    ULONG                   Status;
} NDISUIO_REQUEST, *PNDISUIO_REQUEST;

//
//  Send packet pool bounds
//
#define MIN_SEND_PACKET_POOL_SIZE    256
#define MAX_SEND_PACKET_POOL_SIZE    400

//
//  ProtocolReserved in sent packets. We save a pointer to the IRP
//  that generated the send.
//
//  The RefCount is used to determine when to free the packet back
//  to its pool. It is used to synchronize between a thread completing
//  a send and a thread attempting to cancel a send.
//
typedef struct _NUIO_SEND_PACKET_RSVD
{
    PIRP                    pIrp;
    ULONG                   RefCount;
} NUIO_SEND_PACKET_RSVD, *PNUIO_SEND_PACKET_RSVD;

//
//  Receive packet pool bounds
//
#define MIN_RECV_PACKET_POOL_SIZE    4096
#define MAX_RECV_PACKET_POOL_SIZE    5120

//
//  Max receive packets we allow to be queued up
//
#define MAX_RECV_QUEUE_SIZE          MIN_RECV_PACKET_POOL_SIZE

//
//  ProtocolReserved in received packets: we link these
//  packets up in a queue waiting for Read IRPs.
//
typedef struct _NUIO_RECV_PACKET_RSVD
{
    LIST_ENTRY              Link;
    PNDIS_BUFFER            pOriginalBuffer;    // used if we had to partial-map
	PIRP					pIrp;
} NUIO_RECV_PACKET_RSVD, *PNUIO_RECV_PACKET_RSVD;

#include <pshpack1.h>

typedef struct _NDISUIO_ETH_HEADER
{
    UCHAR       DstAddr[NUIO_MAC_ADDR_LEN];
    UCHAR       SrcAddr[NUIO_MAC_ADDR_LEN];
    USHORT      EthType;
} NDISUIO_ETH_HEADER;

typedef struct _NDISUIO_ETH_HEADER UNALIGNED * PNDISUIO_ETH_HEADER;

#include <poppack.h>

extern NDISUIO_GLOBALS      Globals;

#ifndef NDIS51
#define NdisGetPoolFromPacket(_Pkt) (_Pkt->Private.Pool)
#endif

#ifndef NdisQueryPacketLength

/*++

VOID
NdisQueryPacketLength(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );

--*/

#define NdisQueryPacketLength(_Packet,                                      \
                              _TotalPacketLength)                           \
{                                                                           \
    if (!(_Packet)->Private.ValidCounts)                                    \
    {                                                                       \
        NdisQueryPacket(_Packet, NULL, NULL, NULL, _TotalPacketLength);     \
    }                                                                       \
    else *(_TotalPacketLength) = (_Packet)->Private.TotalLength;            \
}

#endif

//
//  Prototypes.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   pDriverObject,
    IN PUNICODE_STRING  pRegistryPath
    );

VOID
NdisuioUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
NdisuioOpen(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisuioClose(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisuioCleanup(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
NdisuioIoControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
ndisuioOpenDevice(
    IN PUCHAR                   pDeviceName,
    IN ULONG                    DeviceNameLength,
    IN PFILE_OBJECT             pFileObject,
    OUT PNDISUIO_OPEN_CONTEXT * ppOpenContext
    );

VOID
ndisuioRefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioDerefOpen(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

#if DBG
VOID
ndisuioDbgRefOpen(
    IN PNDISUIO_OPEN_CONTEXT    pOpenContext,
    IN LPCSTR					pFilename,
    IN ULONG					LineNumber
    );

VOID
ndisuioDbgDerefOpen(
    IN PNDISUIO_OPEN_CONTEXT	pOpenContext,
    IN LPCSTR					pFilename,
    IN ULONG					LineNumber
    );
#endif // DBG

VOID
NdisuioBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  BindContext,
    IN PNDIS_STRING                 DeviceName,
    IN PVOID                        SystemSpecific1,
    IN PVOID                        SystemSpecific2
    );

VOID
NdisuioOpenAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status,
    IN NDIS_STATUS                  OpenErrorCode
    );

VOID
NdisuioUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  UnbindContext
    );

VOID
NdisuioCloseAdapterComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    );


NDIS_STATUS
NdisuioPnPEventHandler(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNET_PNP_EVENT               pNetPnPEvent
    );

NDIS_STATUS
ndisuioCreateBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

VOID
ndisuioShutdownBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioFreeBindResources(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioWaitForPendingIO(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN BOOLEAN                      DoCancelReads
    );

VOID
ndisuioDoProtocolUnload(
    VOID
    );

NDIS_STATUS
ndisuioDoRequest(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN UINT                         InformationBufferLength,
    OUT PUINT                       pBytesProcessed
    );

NDIS_STATUS
ndisuioValidateOpenAndDoRequest(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN NDIS_REQUEST_TYPE            RequestType,
    IN NDIS_OID                     Oid,
    IN PVOID                        InformationBuffer,
    IN UINT                         InformationBufferLength,
    OUT PUINT                       pBytesProcessed,
    IN BOOLEAN                      bWaitForPowerOn
    );

VOID
NdisuioResetComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  Status
    );

VOID
NdisuioRequestComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_REQUEST                pNdisRequest,
    IN NDIS_STATUS                  Status
    );

VOID
NdisuioStatus(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_STATUS                  GeneralStatus,
    IN PVOID                        StatusBuffer,
    IN UINT                         StatusBufferSize
    );

VOID
NdisuioStatusComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    );

NDIS_STATUS
ndisuioQueryBinding(
    IN PUCHAR                       pBuffer,
    IN ULONG                        InputLength,
    IN ULONG                        OutputLength,
    OUT PULONG                      pBytesReturned
    );

PNDISUIO_OPEN_CONTEXT
ndisuioLookupDevice(
    IN PUCHAR                       pBindingInfo,
    IN ULONG                        BindingInfoLength
    );

NDIS_STATUS
ndisuioQueryOidValue(
    IN  PNDISUIO_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength,
    OUT PULONG                      pBytesWritten
    );

NDIS_STATUS
ndisuioSetOidValue(
    IN  PNDISUIO_OPEN_CONTEXT       pOpenContext,
    OUT PVOID                       pDataBuffer,
    IN  ULONG                       BufferLength
    );

BOOLEAN
ndisuioValidOid(
    IN  NDIS_OID                    Oid
    );

NTSTATUS
NdisuioRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
NdisuioCancelRead(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
ndisuioServiceReads(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

NDIS_STATUS
NdisuioReceive(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN NDIS_HANDLE                  MacReceiveContext,
    IN PVOID                        pHeaderBuffer,
    IN UINT                         HeaderBufferSize,
    IN PVOID                        pLookaheadBuffer,
    IN UINT                         LookaheadBufferSize,
    IN UINT                         PacketSize
    );

VOID
NdisuioTransferDataComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  TransferStatus,
    IN UINT                         BytesTransferred
    );

VOID
NdisuioReceiveComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext
    );

INT
NdisuioReceivePacket(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
ndisuioShutdownBinding(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioQueueReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pRcvPacket
    );

PNDIS_PACKET
ndisuioAllocateReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN UINT                         DataLength,
    OUT PUCHAR *                    ppDataBuffer
    );

VOID
ndisuioFreeReceivePacket(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext,
    IN PNDIS_PACKET                 pNdisPacket
    );

VOID
ndisuioCancelPendingReads(
    IN PNDISUIO_OPEN_CONTEXT        pOpenContext
    );

VOID
ndisuioFlushReceiveQueue(
    IN PNDISUIO_OPEN_CONTEXT            pOpenContext
    );

NTSTATUS
NdisuioWrite(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

VOID
NdisuioCancelWrite(
    IN PDEVICE_OBJECT               pDeviceObject,
    IN PIRP                         pIrp
    );

VOID
NdisuioSendComplete(
    IN NDIS_HANDLE                  ProtocolBindingContext,
    IN PNDIS_PACKET                 pNdisPacket,
    IN NDIS_STATUS                  Status
    );

#endif


